# ==================================================
# Path: E:\Dai Hoc\Nam 3\An toan mang\cert-monitor
# Detected tech: go, javascript
# ==================================================

## DIRECTORY STRUCTURE
```
cert-monitor/
‚îú‚îÄ‚îÄ .git/
‚îú‚îÄ‚îÄ cert-monitor-native/
‚îÇ   ‚îú‚îÄ‚îÄ cert-native.exe
‚îÇ   ‚îú‚îÄ‚îÄ debug_log.txt
‚îÇ   ‚îú‚îÄ‚îÄ install.bat
‚îÇ   ‚îú‚îÄ‚îÄ main.go
‚îÇ   ‚îî‚îÄ‚îÄ nm_host.json
‚îú‚îÄ‚îÄ cmd/
‚îÇ   ‚îú‚îÄ‚îÄ cert-monitor/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ main.go
‚îÇ   ‚îú‚îÄ‚îÄ experiment/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ main.go
‚îÇ   ‚îî‚îÄ‚îÄ experiment_mitm/
‚îÇ       ‚îî‚îÄ‚îÄ main.go
‚îú‚îÄ‚îÄ images/
‚îÇ   ‚îú‚îÄ‚îÄ icon-128.png
‚îÇ   ‚îú‚îÄ‚îÄ icon-16.png
‚îÇ   ‚îî‚îÄ‚îÄ icon-48.png
‚îú‚îÄ‚îÄ internal/
‚îÇ   ‚îú‚îÄ‚îÄ checker/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ checker.go
‚îÇ   ‚îú‚îÄ‚îÄ config/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ config.go
‚îÇ   ‚îú‚îÄ‚îÄ evaluator/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ evaluator.go
‚îÇ   ‚îî‚îÄ‚îÄ notifier/
‚îÇ       ‚îî‚îÄ‚îÄ slack.go
‚îú‚îÄ‚îÄ .gitignore
‚îú‚îÄ‚îÄ README.md
‚îú‚îÄ‚îÄ background.js
‚îú‚îÄ‚îÄ cert-monitor
‚îú‚îÄ‚îÄ cert-monitor.exe
‚îú‚îÄ‚îÄ checking.html
‚îú‚îÄ‚îÄ checking.js
‚îú‚îÄ‚îÄ config.toml
‚îú‚îÄ‚îÄ go.mod
‚îú‚îÄ‚îÄ go.sum
‚îú‚îÄ‚îÄ main.go(cert-monitor).txt
‚îú‚îÄ‚îÄ main.go(cert-monitor-native).txt
‚îú‚îÄ‚îÄ manifest.json
‚îú‚îÄ‚îÄ mitm_latency_results.csv
‚îú‚îÄ‚îÄ popup.html
‚îú‚îÄ‚îÄ popup.js
‚îú‚îÄ‚îÄ results_fp_analysis copy.csv
‚îú‚îÄ‚îÄ results_fp_analysis.csv
‚îú‚îÄ‚îÄ source_dump.txt
‚îú‚îÄ‚îÄ top-1k.csv
‚îî‚îÄ‚îÄ tranco.csv
```

## FILE CONTENTS

### background.js
```js
// File: background.js

// --- C·∫§U H√åNH ---
const API_ENDPOINT = 'http://localhost:8080/check-cert';
const NATIVE_HOST_NAME = "com.certmonitor.native"; // Ph·∫£i kh·ªõp v·ªõi file nm_host.json

// Cache Whitelist phi√™n l√†m vi·ªác
const safeSessionCache = {}; 

// Bi·∫øn to√†n c·ª•c l∆∞u tr·∫°ng th√°i Strict Mode
let isStrictMode = false;

// --- KH·ªûI T·∫†O ---
chrome.storage.sync.get(['strictMode'], (result) => {
    isStrictMode = result.strictMode || false;
});

chrome.storage.onChanged.addListener((changes, namespace) => {
    if (changes.strictMode) {
        isStrictMode = changes.strictMode.newValue;
        if (!isStrictMode) { 
            for (let member in safeSessionCache) delete safeSessionCache[member];
        }
    }
});

// --- H√ÄM G·ªåI NATIVE APP ---
function getNativeFingerprint(domain) {
    return new Promise((resolve) => {
        try {
            console.log(`[Native] Asking OS for certificate of: ${domain}`);
            chrome.runtime.sendNativeMessage(NATIVE_HOST_NAME, { domain: domain }, (response) => {
                if (chrome.runtime.lastError) {
                    console.error("Native Error:", chrome.runtime.lastError.message);
                    resolve(null);
                } else {
                    if (response && response.fingerprint) {
                        resolve(response.fingerprint);
                    } else {
                        resolve(null);
                    }
                }
            });
        } catch (e) {
            console.error(e);
            resolve(null);
        }
    });
}

// --- PH·∫¶N 1: LOGIC CH·∫∂N (STRICT MODE) ---
function shouldIntercept(url) {
    try {
        const urlObj = new URL(url);
        if (urlObj.protocol !== 'https:') return false;
        if (url.startsWith(chrome.runtime.getURL(""))) return false;

        const hostname = urlObj.hostname;
        
        if (safeSessionCache[hostname] && (Date.now() - safeSessionCache[hostname] < 600000)) {
            return false;
        }
        return true;
    } catch (e) { return false; }
}

chrome.tabs.onUpdated.addListener((tabId, changeInfo, tab) => {
    if (tab.url && (changeInfo.status === 'loading' || changeInfo.url)) {
        if (isStrictMode) {
            if (shouldIntercept(tab.url)) {
                const checkingUrl = chrome.runtime.getURL('checking.html') + 
                                    `?target=${encodeURIComponent(tab.url)}`;
                chrome.tabs.update(tabId, { url: checkingUrl });
            }
        } else {
            // Passive Mode
            if (tab.url.startsWith('https') && changeInfo.status === 'complete') {
                checkAndSendResult(tab.url, tabId);
            }
        }
    }
});

// --- PH·∫¶N 2: X·ª¨ L√ù TIN NH·∫ÆN (QUAN TR·ªåNG) ---
chrome.runtime.onMessage.addListener((request, sender, sendResponse) => {
    
    // 2.1. Whitelist
    if (request.action === "mark_as_safe") {
        const hostname = new URL(request.url).hostname;
        safeSessionCache[hostname] = Date.now();
        sendResponse({status: "ok"});
    }

    // 2.2. VALIDATE TOFU (STRICT MODE)
    // S·ª¨A ƒê·ªîI: H·ªó tr·ª£ ki·ªÉm tra danh s√°ch Fingerprints (Multi-IP)
    if (request.action === "validate_tofu") {
        const domain = request.domain;
        
        // Nh·∫≠n c·∫£ danh s√°ch (n·∫øu c√≥) ho·∫∑c 1 c√°i (fallback)
        const validFingerprints = request.fingerprints || [];
        if (request.fingerprint) validFingerprints.push(request.fingerprint);

        getNativeFingerprint(domain).then((localFingerprint) => {
            let isSafe = true;
            let error = "";

            if (!localFingerprint) {
                isSafe = false;
                error = "Native Host Unreachable";
            } else {
                const localClean = localFingerprint.toLowerCase();
                
                // SO S√ÅNH TH√îNG MINH: Local c√≥ n·∫±m trong danh s√°ch Valid kh√¥ng?
                const isMatch = validFingerprints.some(fp => fp.toLowerCase() === localClean);

                if (!isMatch) {
                    isSafe = false;
                    error = `MITM DETECTED! Local (${localClean.substring(0,8)}...) not found in valid Agent list.`;
                    console.warn(`MITM ALERT ${domain}: Local mismatch`);
                } else {
                    console.log(`Integrity Confirmed for ${domain}`);
                }
            }

            sendResponse({ isSafe: isSafe, error: error });
        });

        return true; 
    }

    // 2.3. Passive Check
    if (request.action === "request_cert_check") {
        checkAndSendResult(request.url, request.tabId);
        return true;
    }
});

// --- PH·∫¶N 3: LOGIC CHECK PASSIVE ---
async function checkAndSendResult(url, tabId) {
    let result = {
        issuer: "Checking...",
        securityScore: 0,
        riskLevel: "UNKNOWN",
        isMITM: false,
        error: null
    };

    try {
        const hostname = new URL(url).hostname;

        // 1. G·ªçi API Go Server
        const response = await fetch(API_ENDPOINT, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ domain: hostname })
        });
        
        if(!response.ok) throw new Error("Agent Failed");
        const apiData = await response.json();
        
        result = { ...result, ...apiData };

        // 2. L·∫•y Native Fingerprint
        const localFingerprint = await getNativeFingerprint(hostname);

        // 3. SO S√ÅNH (MULTI-IP AWARE)
        if (localFingerprint) {
            const localClean = localFingerprint.toLowerCase();
            let isMatch = false;

            // ∆Øu ti√™n check m·∫£ng fingerprints
            if (apiData.fingerprints && apiData.fingerprints.length > 0) {
                isMatch = apiData.fingerprints.some(fp => fp.toLowerCase() === localClean);
            } else if (apiData.fingerprint) {
                isMatch = (localClean === apiData.fingerprint.toLowerCase());
            }

            if (!isMatch) {
                result.isMITM = true;
                result.error = "MITM DETECTED (Native Check)";
                result.shouldAlert = true;
                result.securityScore = 0;
            }
        }

    } catch (e) {
        console.error(e);
        result.error = e.message;
    }

    chrome.runtime.sendMessage({ action: "cert_status_update", ...result }).catch(()=>{});
    updateBadge(tabId, result);
}

function updateBadge(tabId, result) {
    let color = '#00AA00';
    let text = result.securityScore ? result.securityScore.toString() : "";
    if (result.isMITM) { color = '#FF0000'; text = "MITM"; }
    else if (result.shouldAlert) { color = '#FF0000'; text = "!"; }
    
    if (tabId) {
        try {
            chrome.action.setBadgeBackgroundColor({ color: color, tabId: tabId });
            chrome.action.setBadgeText({ text: text, tabId: tabId });
        } catch(e) {}
    }
}
```

### checking.js
```js
// File: checking.js
const API_ENDPOINT = 'http://localhost:8080/check-cert';

const params = new URLSearchParams(window.location.search);
const targetUrl = params.get('target');

if (targetUrl) {
    performCheck();
} else {
    document.body.innerHTML = "<h1>Invalid Target URL</h1>";
}

// X·ª≠ l√Ω s·ª± ki·ªán n√∫t Bypass
document.getElementById('bypass-btn').addEventListener('click', () => {
    if (confirm("WARNING: You are bypassing security checks.\nIf the Agent is unreachable due to an attack, your connection might be compromised.\n\nAre you sure you want to proceed?")) {
        allowAccess();
    }
});

async function performCheck() {
    let hostname = "";
    try {
        hostname = new URL(targetUrl).hostname;
    } catch (e) {
        showBlockScreen("Unknown", "Invalid URL format", 0, false);
        return;
    }

    // Thi·∫øt l·∫≠p Timeout 3 gi√¢y (Fail-safe)
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), 3000);

    try {
        // B∆Ø·ªöC 1: G·ªçi Go Server (L·∫•y Fingerprint chu·∫©n)
        const response = await fetch(API_ENDPOINT, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ domain: hostname }),
            signal: controller.signal // G·∫Øn t√≠n hi·ªáu ng·∫Øt
        });
        clearTimeout(timeoutId); // H·ªßy timeout n·∫øu th√†nh c√¥ng

        if (!response.ok) throw new Error("Agent connection failed");
        const data = await response.json();

        // Check s∆° b·ªô t·ª´ Server (ƒêi·ªÉm s·ªë)
        if (data.security_score < 50 || data.risk_level === 'CRITICAL') {
            // L·ªói b·∫£o m·∫≠t th·∫≠t -> Ch·∫∑n c·ª©ng (Kh√¥ng cho Bypass)
            showBlockScreen(hostname, data.error || "Low Security Score", data.security_score, false);
            return;
        }

        // B∆Ø·ªöC 2: H·ªèi Background (Native Host) xem c√≥ kh·ªõp kh√¥ng?
        chrome.runtime.sendMessage({ 
            action: "validate_tofu", 
            domain: hostname, 
            fingerprints: data.fingerprints 
        }, (tofuResult) => {
            
            if (tofuResult && tofuResult.isSafe) {
                // --- AN TO√ÄN ---
                allowAccess();
            } else {
                // --- MITM TH·∫¨T (Server OK nh∆∞ng Local L·ªách) ---
                // Ch·∫∑n c·ª©ng (Kh√¥ng cho Bypass)
                const errorMsg = tofuResult ? tofuResult.error : "TOFU Validation Failed";
                showBlockScreen(hostname, errorMsg, 0, false);
            }
        });

    } catch (e) {
        // --- FAIL-SAFE: L·ªñI M·∫†NG / TIMEOUT ---
        // N·∫øu kh√¥ng g·ªçi ƒë∆∞·ª£c Agent, cho ph√©p ng∆∞·ªùi d√πng t·ª± quy·∫øt ƒë·ªãnh (Soft Fail)
        console.warn("Agent unreachable:", e);
        
        let reason = "Verification Agent Unreachable (Timeout/Network Error).";
        reason += "<br><small>Cannot verify certificate integrity.</small>";

        // Hi·ªán m√†n h√¨nh ch·∫∑n nh∆∞ng CHO PH√âP n√∫t Bypass
        showBlockScreen(hostname, reason, "?", true);
    }
}

function allowAccess() {
    // B√°o whitelist ƒë·ªÉ l·∫ßn sau kh√¥ng ch·∫∑n n·ªØa
    chrome.runtime.sendMessage({ action: "mark_as_safe", url: targetUrl }, () => {
        window.location.replace(targetUrl);
    });
}

function showBlockScreen(domain, error, score, allowBypass) {
    document.getElementById('loading-view').classList.add('hidden');
    document.getElementById('blocked-view').classList.remove('hidden');
    
    const mainCard = document.getElementById('main-card');
    const title = document.getElementById('status-title');
    
    document.getElementById('target-domain').textContent = domain;
    document.getElementById('error-reason').innerHTML = error; // D√πng innerHTML ƒë·ªÉ xu·ªëng d√≤ng
    document.getElementById('security-score').textContent = score;

    const bypassBtn = document.getElementById('bypass-btn');

    if (allowBypass) {
        // Ch·∫ø ƒë·ªô C·∫£nh b√°o (Warning) - Cho ph√©p ƒëi ti·∫øp
        bypassBtn.style.display = 'inline-block';
        mainCard.classList.remove('blocked');
        mainCard.classList.add('warning'); // Vi·ªÅn m√†u cam
        title.style.color = "#f39c12";
        title.textContent = "Connection Warning";
    } else {
        // Ch·∫ø ƒë·ªô Ch·∫∑n (Blocked) - MITM ho·∫∑c r·ªßi ro cao
        bypassBtn.style.display = 'none';
        mainCard.classList.remove('warning');
        mainCard.classList.add('blocked'); // Vi·ªÅn m√†u ƒë·ªè
        title.style.color = "#c0392b";
        title.textContent = "Connection Blocked";
    }
}
```

### popup.js
```js
// File: popup.js
document.addEventListener('DOMContentLoaded', function() {
    const statusDiv = document.getElementById('status');
    const strictToggle = document.getElementById('strictModeToggle');
  
    // 1. Load tr·∫°ng th√°i Strict Mode t·ª´ b·ªô nh·ªõ
    chrome.storage.sync.get(['strictMode'], function(result) {
        strictToggle.checked = result.strictMode || false;
    });
  
    // 2. L·∫Øng nghe s·ª± ki·ªán B·∫≠t/T·∫Øt Switch
    strictToggle.addEventListener('change', function() {
        const isStrict = strictToggle.checked;
        chrome.storage.sync.set({ strictMode: isStrict }, function() {
            console.log("Strict Mode set to " + isStrict);
            // Reload tab hi·ªán t·∫°i ƒë·ªÉ √°p d·ª•ng ngay l·∫≠p t·ª©c
            chrome.tabs.query({active: true, currentWindow: true}, function(tabs) {
                if(tabs[0]) chrome.tabs.reload(tabs[0].id);
            });
        });
    });
  
    // 3. Logic hi·ªÉn th·ªã th√¥ng tin c≈©
    statusDiv.innerHTML = "<p>Connecting to Hybrid Agent...</p>"; 
  
    chrome.runtime.onMessage.addListener((request, sender, sendResponse) => {
        if (request.action === "cert_status_update") {
          renderResult(request);
        }
    });
  
    chrome.tabs.query({ active: true, currentWindow: true }, function(tabs) {
      if (tabs[0] && tabs[0].url.startsWith("https")) {
        chrome.runtime.sendMessage({ 
            action: "request_cert_check", 
            url: tabs[0].url,
            tabId: tabs[0].id
        });
      } else {
        statusDiv.innerHTML = "<p style='color:gray; padding:10px;'>Please verify an HTTPS website.</p>";
      }
    });
  });
  
  function renderResult(data) {
      const statusDiv = document.getElementById('status');
      
      let scoreColor = '#2ecc71'; // Green
      if (data.securityScore < 50) scoreColor = '#e74c3c'; // Red
      else if (data.securityScore < 80) scoreColor = '#f39c12'; // Orange
  
      let html = `
          <div style="text-align: center; padding: 15px; background: #f9f9f9; border-bottom: 1px solid #eee;">
              <div style="font-size: 36px; color: ${scoreColor}; font-weight: bold;">
                  ${data.securityScore !== undefined ? data.securityScore : "?"}
              </div>
              <div style="font-size: 12px; color: #7f8c8d; text-transform: uppercase; letter-spacing: 1px;">Security Score</div>
          </div>
      `;
  
      if (data.isMITM) {
          html += `
              <div style="background-color: #c0392b; color: white; padding: 10px; margin: 10px 0; font-weight: bold; text-align: center; border-radius: 4px;">
                  üö® MITM ATTACK DETECTED üö®
                  <div style="font-size: 10px; font-weight: normal;">Certificate fingerprint mismatch!</div>
              </div>
          `;
      } else if (data.error) {
          html += `<div style="color: #c0392b; padding: 10px; font-size: 12px;">Error: ${data.error}</div>`;
      }
  
      if (data.issuer) {
          html += `
              <div style="padding: 15px; font-size: 13px; line-height: 1.6;">
                  <div><strong>Issuer:</strong> ${data.issuer}</div>
                  <div><strong>Expires:</strong> ${data.expiryDate}</div>
                  <div><strong>Days Left:</strong> <span style="color:${data.daysLeft < 30 ? 'red' : 'green'}">${data.daysLeft}</span></div>
                  <div><strong>Algorithm:</strong> ${data.signatureAlgorithm}</div>
                  <div style="margin-top: 8px; font-size: 10px; color: #95a5a6; word-break: break-all;">
                      <strong>Fingerprint (SHA256):</strong><br>
                      ${data.fingerprint ? data.fingerprint.substring(0, 20) + "..." : "N/A"}
                  </div>
              </div>
          `;
      }
  
      statusDiv.innerHTML = html;
  }
```
